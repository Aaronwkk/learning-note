#### websocket 握手过程

WebSocket握手过程是一个从HTTP协议转换到WebSocket协议的关键步骤，确保了客户端和服务端能够以全双工的方式进行低延迟的数据通信。下面是WebSocket握手的详细过程：

1. **建立TCP连接**：首先，客户端（如浏览器）与服务器之间需要通过TCP协议建立连接，这是所有基于TCP的应用层协议（包括HTTP和WebSocket）的基础。

2. **客户端发送握手请求**：一旦TCP连接建立，客户端会发送一个特殊的HTTP请求到服务器，这个请求通常是一个`GET`方法的HTTP请求。请求头中包含特定的字段，用来告诉服务器客户端希望将连接升级为WebSocket连接。关键的头部字段包括：
   - `Upgrade`: 必须设置为`websocket`，表明这是一个协议升级请求。
   - `Connection`: 必须设置为`Upgrade`，表示客户端希望升级当前的连接。
   - `Sec-WebSocket-Key`: 包含一个随机生成的Base64编码密钥，服务器将用它来验证客户端。
   - `Sec-WebSocket-Version`: 指定WebSocket协议版本，通常是13，表示最新的稳定版本。

3. **服务器响应握手**：服务器收到请求后，如果支持WebSocket并且验证通过，会返回一个HTTP响应，状态码为`101 Switching Protocols`，表示服务器同意升级协议。响应头中同样包含重要的字段：
   - `Upgrade`: 设置为`websocket`，确认协议升级。
   - `Connection`: 设置为`Upgrade`，确认连接升级。
   - `Sec-WebSocket-Accept`: 服务器计算得到的一个值，它是将客户端提供的`Sec-WebSocket-Key`与一个固定的字符串拼接后，通过SHA-1算法计算摘要，再进行Base64编码得到的。这是服务器对客户端握手请求的确认。

4. **连接升级**：一旦客户端验证了服务器的响应有效，就认为握手成功，此时HTTP连接被升级为WebSocket连接，双方开始使用WebSocket协议进行数据传输。

**常见的WebSocket面试题**可能包括但不限于：

1. **WebSocket与传统HTTP长轮询的区别**：WebSocket提供真正的全双工通信，而长轮询是模拟实时通信，效率较低。
   
2. **WebSocket的帧结构**：如何理解WebSocket的数据帧格式，包括控制帧、文本帧和二进制帧的结构和用途。
   
3. **WebSocket的安全性**：如何通过WSS（WebSocket over TLS/SSL）确保通信的安全性。
   
4. **WebSocket的心跳机制**：如何使用Ping/Pong帧维持长连接活跃状态。
   
5. **处理错误和断线重连**：WebSocket连接断开时，客户端和服务端如何处理，以及如何实现自动重连机制。
   
6. **WebSocket的使用场景**：列举WebSocket在实时聊天、在线游戏、金融交易、物联网等领域的应用实例。
   
7. **如何在WebSocket中实现消息的有序性和可靠性**：探讨如何设计协议或采用机制来确保消息的顺序和不丢失。
   
这些问题不仅考察对WebSocket协议本身的理解，也涉及其实现细节和在实际应用中的考量。

#### Sec-WebSocket-Key 讲述下这个字段的认证过程

`Sec-WebSocket-Key`字段是WebSocket握手过程中客户端发送给服务器的一个重要头部信息，用于帮助服务器验证本次握手请求的合法性，并确保连接的双方都支持WebSocket协议。其认证过程具体如下：

1. **客户端生成密钥**：当客户端初始化WebSocket连接请求时，它会生成一个16字节（即128位）的随机数据。这个随机数据通常是没有特殊意义的，可以视为一个令牌。

2. **Base64编码**：为了能在HTTP头部中安全传输，这16字节的随机数据会被转换成Base64编码格式。Base64是一种将二进制数据转换为ASCII字符的编码方式，常用于电子邮件和HTTP传输中表示二进制数据。

3. **附加到请求头**：编码后的字符串作为值，添加到`Sec-WebSocket-Key`头部字段中，随同其他HTTP头部一起发送给服务器。

4. **服务器验证**：服务器收到请求后，会读取`Sec-WebSocket-Key`的值。为了验证客户端，服务器需要执行以下步骤：
   - 解码：首先，服务器会对Base64编码的密钥进行解码，还原出原始的16字节随机数据。
   - 增加固定字符串：然后，服务器会将这个随机数据与一个固定的字符串（"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"，这是WebSocket协议定义的魔术字符串）拼接在一起。
   - SHA-1哈希：接着，对拼接后的字符串进行SHA-1哈希运算，生成一个20字节的哈希值。
   - Base64编码：最后，将得到的哈希值再进行Base64编码。

5. **构建响应**：服务器将这个经过计算得到的Base64编码字符串作为`Sec-WebSocket-Accept`头部字段的值，包含在HTTP响应中发送回客户端。

6. **客户端验证**：客户端收到服务器的响应后，会检查`Sec-WebSocket-Accept`字段的值。如果该值与客户端自己计算的结果一致（即客户端也进行了相同的密钥+固定字符串的哈希及Base64编码过程），则认为服务器正确地处理了握手请求，且是有效的WebSocket服务器。这样，握手完成，双方可以开始WebSocket数据传输。

这个过程确保了握手请求的发起方确实了解WebSocket协议，并且能与服务器完成约定的密钥交换，从而防止了非WebSocket协议的误连接或恶意攻击。

#### 这是WebSocket协议定义的魔术字符串 这个字符串的作用？

WebSocket协议中定义的“魔术字符串”——"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"，扮演着关键的安全校验角色。它的主要作用如下：

1. **协议识别与安全性验证**：这个特定的字符串作为一个协议级别的标识符，用于验证通信双方确实遵循的是WebSocket协议。当客户端和服务端通过这个特定字符串完成握手时，实际上是在确认双方都理解并能够遵循WebSocket的握手规则，增加了握手过程的安全性。

2. **防止非WebSocket流量**：通过在握手过程中加入这一固定的、事先约定好的字符串，并要求服务器将其与客户端提供的密钥结合后进行哈希运算，可以有效阻止非WebSocket协议的流量尝试建立连接。因为非WebSocket的客户端不会知道如何正确生成或验证这一部分，从而避免了协议被滥用的风险。

3. **握手完整性校验**：服务器通过将客户端提供的密钥与魔术字符串拼接后进行哈希运算，并将结果返回给客户端，客户端再进行匹配校验。这一过程确保了握手消息没有被篡改，因为即使是微小的改变也会导致哈希值不同，握手失败。

简而言之，这个魔术字符串是WebSocket协议握手阶段一个核心的安全机制，确保了连接的双方都是合法的WebSocket实现，并且握手信息没有被第三方干扰，提高了通信的安全性和可靠性。