#### 前端项目如何找出性能瓶颈 #300

为什么遇到性能瓶颈，真的有必要去解决吗？个人觉得可以从两个维度去思考：
①交互设计上：很多情况下，交互设计存在导致页面出现性能瓶颈的问题，在实际应用中，是否可以考虑优化现有交互，比如：列表，是否可以分页？地图撒点，是否可以通过点聚合实现？树型视图，是否可以在交互上懒加载，而不是一次性加载所有？这些类似的场景都不需要直接通过研究底层技术去实现优化，这种方式个人认为是应该优先考虑的。
②技术上：如果已经要考虑这个层面的优化了，证明你已经向产品或者交互妥协，那就专业的研究下在既定场景下，导致性能问题的因素都有哪些？如：加载的资源中重复代码过多，使得文件太大、业务设计不合理导致请求过多、代码编写不规范，造成不必要的浏览器计算，及服务端计算，浪费运行资源、业务代码中关于组件实现上，内部涉及业务的算法上是否有优化的空间、对应用的技术栈理解的不够深入，在使用过程中不合理的运行了一些不必要的框架内部程序，从而导致整个业务单元运行效率降低，从而产生用户可以感知的性能问题。
简而言之：交互优化优先级高于技术性优化


计算资源的缓存命中率
缓存命中率：从缓存中得到数据的请求数与所有请求数的比率
理想状态是缓存命中率越高越好，缓存命中率越高说明网站的缓存策略越有效，用户打开页面的速度也会相应提高
如何判断该资源是否命中缓存？
1）通过performance.getEntries()找到所有资源的信息
2）在这些资源对象中有一个transferSize 字段，它表示获取资源的大小，包括响应头字段和响应数据的大小
3）如果这个值为 0，说明是从缓存中直接读取的（强制缓存）
4）如果这个值不为 0，但是encodedBodySize 字段为 0，说明它走的是协商缓存（encodedBodySize 表示请求响应数据 body 的大小）
js 代码解读复制代码function isCache(entry) {
  // 直接从缓存读取或 304
  return entry.transferSize === 0 || (entry.transferSize !== 0 && entry.encodedBodySize === 0);
}

将所有命中缓存的数据 / 总数据 就能得出缓存命中率